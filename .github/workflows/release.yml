name: "doki-manga-release"

on:
  repository_dispatch:
    types: [build-release]
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to build (e.g., v1.2.3)"
        required: true
        type: string

jobs:
  release-notes:
    runs-on: ubuntu-22.04
    outputs:
      release_body: ${{ steps.release_notes.outputs.release_body }}
    steps:
      - name: Checkout doki source code
        uses: actions/checkout@v4
        with:
          repository: caolib/doki
          ref: ${{ github.event.client_payload.tag || github.event.inputs.tag }}
          token: ${{ secrets.PAT_TOKEN }}

      - id: release_notes
        continue-on-error: true
        run: |
          if [ -f "./docs/RELEASE.md" ]; then
            {
              echo 'release_body<<EOF'
              cat "./docs/RELEASE.md"
              echo 'EOF'
            } >> "$GITHUB_OUTPUT"
          else
            echo "release_body=See the assets to download this version and install." >> "$GITHUB_OUTPUT"
          fi

  publish-tauri:
    needs: [release-notes]
    if: always() && (needs.release-notes.result == 'success' || needs.release-notes.result == 'skipped')
    permissions:
      contents: write
      actions: read
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: "macos-latest" # for Arm based macs (M1 and above).
            args: "--target aarch64-apple-darwin"
          - platform: "macos-latest" # for Intel based macs.
            args: "--target x86_64-apple-darwin"
          - platform: "ubuntu-22.04"
            args: ""
          - platform: "windows-latest"
            args: ""
    runs-on: ${{ matrix.platform }}
    steps:
      # éªŒè¯ç­¾åå¯†é’¥
      - name: Validate Tauri signing key
        shell: bash
        run: |
          echo "ğŸ” éªŒè¯ç­¾åå¯†é’¥..."

          # æ£€æŸ¥å¯†é’¥æ˜¯å¦å­˜åœ¨
          if [ -z "${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}" ]; then
            echo "âŒ é”™è¯¯: TAURI_SIGNING_PRIVATE_KEY å¯†é’¥æœªè®¾ç½®"
            exit 1
          fi

          if [ -z "${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}" ]; then
            echo "âŒ é”™è¯¯: TAURI_SIGNING_PRIVATE_KEY_PASSWORD å¯†ç æœªè®¾ç½®"
            exit 1
          fi

          # éªŒè¯å¯†é’¥æ ¼å¼ï¼ˆbase64è§£ç æµ‹è¯•ï¼‰
          echo "ğŸ” éªŒè¯å¯†é’¥æ ¼å¼..."

          # æ˜¾ç¤ºå½“å‰å¯†é’¥çš„å‰100ä¸ªå­—ç¬¦ç”¨äºè°ƒè¯•
          echo "ğŸ” å½“å‰å¯†é’¥å‰100å­—ç¬¦: $(echo "${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}" | head -c 100)..."

          # è®¡ç®—åŸå§‹base64å­—ç¬¦ä¸²é•¿åº¦
          KEY_LENGTH=$(echo "${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}" | wc -c)
          echo "ğŸ“ base64å­—ç¬¦ä¸²é•¿åº¦: $KEY_LENGTH"

          # å°è¯•è§£ç 
          if ! echo "${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}" | base64 -d > /tmp/test-key.key 2>/tmp/decode-error.log; then
            echo "âŒ é”™è¯¯: ç§é’¥ä¸æ˜¯æœ‰æ•ˆçš„base64æ ¼å¼"
            echo "è§£ç é”™è¯¯ä¿¡æ¯:"
            cat /tmp/decode-error.log
            exit 1
          fi

          # æ£€æŸ¥è§£ç åçš„å¯†é’¥æ–‡ä»¶å¤§å°
          KEY_SIZE=$(stat -c%s /tmp/test-key.key 2>/dev/null || stat -f%z /tmp/test-key.key 2>/dev/null || echo "0")
          echo "ğŸ“¦ è§£ç åæ–‡ä»¶å¤§å°: $KEY_SIZE bytes"

          if [ "$KEY_SIZE" -lt 100 ]; then
            echo "âŒ é”™è¯¯: è§£ç åçš„ç§é’¥æ–‡ä»¶å¤ªå° ($KEY_SIZE bytes)ï¼Œå¯èƒ½è§£ç å¤±è´¥"
            exit 1
          fi

          # æ˜¾ç¤ºè§£ç åæ–‡ä»¶çš„å‰å‡ è¡Œç”¨äºè°ƒè¯•
          echo "ğŸ” è§£ç åæ–‡ä»¶å†…å®¹å‰3è¡Œ:"
          cat /tmp/test-key.key | head -3

          # éªŒè¯å¯†é’¥æ ¼å¼ï¼ˆæ”¯æŒPEMå’Œrsignæ ¼å¼ï¼‰
          if grep -q "BEGIN.*PRIVATE KEY" /tmp/test-key.key; then
            echo "âœ… æ£€æµ‹åˆ°PEMæ ¼å¼ç§é’¥"
          elif grep -q "untrusted comment.*rsign" /tmp/test-key.key; then
            echo "âœ… æ£€æµ‹åˆ°rsignæ ¼å¼ç§é’¥"
          else
            echo "âŒ é”™è¯¯: è§£ç åçš„æ–‡ä»¶ä¸åŒ…å«æœ‰æ•ˆçš„ç§é’¥æ ‡è¯†"
            echo "å®Œæ•´æ–‡ä»¶å†…å®¹:"
            cat /tmp/test-key.key
            exit 1
          fi

          # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
          rm -f /tmp/test-key.key

          echo "âœ… ç­¾åå¯†é’¥éªŒè¯é€šè¿‡ï¼"

      - name: Checkout doki source code
        uses: actions/checkout@v4
        with:
          repository: caolib/doki
          ref: ${{ github.event.client_payload.tag || github.event.inputs.tag }}
          token: ${{ secrets.PAT_TOKEN }}

      - name: install dependencies (ubuntu only)
        if: matrix.platform == 'ubuntu-22.04'
        continue-on-error: true
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Setup pnpm
        uses: pnpm/action-setup@v4.1.0
        with:
          version: 10

      - name: setup node
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: "pnpm"
          cache-dependency-path: "pnpm-lock.yaml"

      - name: install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        continue-on-error: true
        with:
          workspaces: "./src-tauri -> target"
          cache-on-failure: true
          shared-key: ${{ matrix.platform }}
          save-if: ${{ github.ref == 'refs/heads/main' }}

      - name: install frontend dependencies
        run: pnpm install

      # è®¾ç½®æ˜¯å¦ä¸ºé¢„å‘å¸ƒ
      - name: Set prerelease if tag contains beta
        id: set_prerelease
        shell: bash
        run: |
          TAG_NAME=${{ github.event.client_payload.tag || github.event.inputs.tag }}
          if [[ "$TAG_NAME" == *beta* ]]; then
            echo "prerelease=true" >> $GITHUB_OUTPUT
          else
            echo "prerelease=false" >> $GITHUB_OUTPUT
          fi

      # è®¾ç½®ç­¾åå¯†é’¥ç¯å¢ƒå˜é‡
      - name: Setup Tauri signing key
        shell: bash
        run: |
          echo "ğŸ”§ å¼€å§‹å¤„ç†ç­¾åå¯†é’¥..."

          # è·å–åŸå§‹å¯†é’¥
          RAW_KEY="${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}"
          echo "ğŸ“ åŸå§‹å¯†é’¥é•¿åº¦: ${#RAW_KEY}"

          # æ˜¾ç¤ºå¯†é’¥çš„å‰20ä¸ªå­—ç¬¦ç”¨äºè°ƒè¯•ï¼ˆhexæ ¼å¼ï¼‰
          echo "ğŸ” å¯†é’¥å‰20å­—ç¬¦çš„hex: $(echo -n "$RAW_KEY" | head -c 20 | xxd -p)"

          # å°è¯•å¤šç§æ¸…ç†å’Œè§£ç æ–¹å¼
          SUCCESS=false

          # æ–¹æ³•1: ç›´æ¥ä½¿ç”¨åŸå§‹å¯†é’¥è§£ç 
          echo "ğŸ§ª å°è¯•æ–¹æ³•1: ç›´æ¥è§£ç åŸå§‹å¯†é’¥..."
          if echo "$RAW_KEY" | base64 -d > decoded-key.tmp 2>/dev/null; then
            KEY_SIZE=$(stat -c%s decoded-key.tmp 2>/dev/null || stat -f%z decoded-key.tmp 2>/dev/null || echo "0")
            echo "ï¿½ æ–¹æ³•1 è§£ç åæ–‡ä»¶å¤§å°: $KEY_SIZE bytes"
            
            if [ "$KEY_SIZE" -gt 100 ] && grep -q "untrusted comment.*rsign" decoded-key.tmp 2>/dev/null; then
              echo "âœ… æ–¹æ³•1 è§£ç æˆåŠŸï¼ä½¿ç”¨ç›´æ¥å†…å®¹è®¾ç½®"
              # ç›´æ¥è®¾ç½®è§£ç åçš„å†…å®¹åˆ°ç¯å¢ƒå˜é‡
              echo "TAURI_SIGNING_PRIVATE_KEY<<EOF" >> $GITHUB_ENV
              cat decoded-key.tmp >> $GITHUB_ENV
              echo "EOF" >> $GITHUB_ENV
              SUCCESS=true
            fi
          fi

          # æ–¹æ³•2: æ¸…ç†ç©ºç™½å­—ç¬¦åè§£ç 
          if [ "$SUCCESS" = false ]; then
            echo "ğŸ§ª å°è¯•æ–¹æ³•2: æ¸…ç†ç©ºç™½å­—ç¬¦åè§£ç ..."
            CLEAN_KEY=$(echo "$RAW_KEY" | tr -d '[:space:]')
            if echo "$CLEAN_KEY" | base64 -d > decoded-key.tmp 2>/dev/null; then
              KEY_SIZE=$(stat -c%s decoded-key.tmp 2>/dev/null || stat -f%z decoded-key.tmp 2>/dev/null || echo "0")
              echo "ğŸ“¦ æ–¹æ³•2 è§£ç åæ–‡ä»¶å¤§å°: $KEY_SIZE bytes"
              
              if [ "$KEY_SIZE" -gt 100 ] && grep -q "untrusted comment.*rsign" decoded-key.tmp 2>/dev/null; then
                echo "âœ… æ–¹æ³•2 è§£ç æˆåŠŸï¼ä½¿ç”¨æ¸…ç†åå†…å®¹è®¾ç½®"
                echo "TAURI_SIGNING_PRIVATE_KEY<<EOF" >> $GITHUB_ENV
                cat decoded-key.tmp >> $GITHUB_ENV
                echo "EOF" >> $GITHUB_ENV
                SUCCESS=true
              fi
            fi
          fi

          # æ–¹æ³•3: ä½œä¸ºæ–‡ä»¶è·¯å¾„ï¼ˆå¤‡ç”¨ï¼‰
          if [ "$SUCCESS" = false ]; then
            echo "ğŸ§ª å°è¯•æ–¹æ³•3: åˆ›å»ºæ–‡ä»¶å¹¶è®¾ç½®è·¯å¾„..."
            CLEAN_KEY=$(echo "$RAW_KEY" | tr -d '[:space:]')
            if echo "$CLEAN_KEY" | base64 -d > signing-key.key 2>/dev/null; then
              KEY_SIZE=$(stat -c%s signing-key.key 2>/dev/null || stat -f%z signing-key.key 2>/dev/null || echo "0")
              echo "ğŸ“¦ æ–¹æ³•3 è§£ç åæ–‡ä»¶å¤§å°: $KEY_SIZE bytes"
              
              if [ "$KEY_SIZE" -gt 100 ] && grep -q "untrusted comment.*rsign" signing-key.key 2>/dev/null; then
                echo "âœ… æ–¹æ³•3 è§£ç æˆåŠŸï¼ä½¿ç”¨æ–‡ä»¶è·¯å¾„è®¾ç½®"
                echo "TAURI_SIGNING_PRIVATE_KEY=$(pwd)/signing-key.key" >> $GITHUB_ENV
                SUCCESS=true
              fi
            fi
          fi

          # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
          rm -f decoded-key.tmp

          if [ "$SUCCESS" = false ]; then
            echo "âŒ æ‰€æœ‰è§£ç æ–¹æ³•éƒ½å¤±è´¥äº†"
            echo "å°è¯•æ˜¾ç¤ºåŸå§‹å¯†é’¥çš„è¯¦ç»†ä¿¡æ¯ï¼š"
            echo "é•¿åº¦: ${#RAW_KEY}"
            echo "å‰50å­—ç¬¦: $(echo -n "$RAW_KEY" | head -c 50)"
            echo "æ˜¯å¦åŒ…å«æ¢è¡Œ: $(echo -n "$RAW_KEY" | wc -l)"
            exit 1
          fi

          echo "âœ… ç­¾åå¯†é’¥è®¾ç½®æˆåŠŸ"
          echo "TAURI_SIGNING_PRIVATE_KEY_PASSWORD=${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}" >> $GITHUB_ENV      - uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ env.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ env.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          tagName: ${{ github.event.client_payload.tag || github.event.inputs.tag }}
          releaseName: "Release ${{ github.event.client_payload.tag || github.event.inputs.tag }}"
          releaseBody: ${{ needs.release-notes.outputs.release_body || 'See the assets to download this version and install.' }}
          releaseDraft: false
          prerelease: ${{ steps.set_prerelease.outputs.prerelease }}
          args: ${{ matrix.args }}
          includeUpdaterJson: true
